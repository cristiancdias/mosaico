<!DOCTYPE html>
<html lang="pt-br">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>Mosaico 61 Imagens com Bordas e Painel Flutuante</title>
    <style>
      body {
        background-color: #fff;
        color: #000;
        font-family: sans-serif;
        text-align: center;
        padding: 20px;
        user-select: none;
      }
      h1 {
        color: #0044cc;
      }
      .grid-container {
        display: grid;
        grid-template-columns: repeat(2, 500px);
        grid-gap: 5px;
        justify-content: center;
        margin: 20px auto;
        max-width: 1140px;
      }
      .grid-cell {
        width: 500px;
        height: 500px;
        background-color: #eee;
        border: 12px solid transparent;
        background: linear-gradient(#fff, #fff) padding-box,
          linear-gradient(-45deg, #ff0055, #1e723a) border-box;
        padding: 20px;
        position: relative;
        overflow: hidden;
        cursor: pointer;
      }
      .grid-cell input {
        display: none;
      }
      .grid-cell canvas {
        position: absolute;
        top: 0;
        left: 0;
        user-select: none;
      }
      #controls {
        position: fixed;
        top: 40px;
        right: 40px;
        width: 320px;
        background: #f0f0f0;
        border: 3px solid #007bff;
        border-radius: 8px;
        padding: 15px;
        z-index: 1000;
        box-shadow: 0 4px 8px rgba(0, 0, 0, 0.15);
        user-select: none;
      }
      #dragHandle {
        background: #007bff;
        color: white;
        padding: 8px;
        font-weight: bold;
        cursor: grab;
        user-select: none;
        border-radius: 5px 5px 0 0;
        margin: -15px -15px 15px -15px;
        text-align: center;
      }
      #controls.hidden {
        display: none;
      }
      #controls label {
        display: block;
        margin: 12px 0 6px;
        font-weight: bold;
      }
      #controls input[type="range"] {
        width: 100%;
      }
      #generate {
        margin-top: 20px;
        padding: 12px 24px;
        background-color: #007bff;
        color: white;
        border: none;
        font-size: 18px;
        cursor: pointer;
        border-radius: 5px;
        user-select: none;
      }
      #generate:hover {
        background-color: #0056b3;
      }
    </style>
  </head>
  <body>
    <h1>Mosaico de 61 Imagens</h1>
    <p>
      Clique em um quadrado para carregar a imagem. Ajuste zoom e posição para
      cada imagem.
    </p>

    <div class="grid-container" id="grid"></div>

    <div
      id="controls"
      class="hidden"
      title="Arraste pela barra azul para mover"
    >
      <div id="dragHandle">Painel de Ajustes (arraste aqui)</div>
      <label
        >Zoom
        <input
          type="range"
          id="zoomControl"
          min="0.1"
          max="5"
          step="0.05"
          value="1"
        />
      </label>
      <label
        >Posição X
        <input
          type="range"
          id="xControl"
          min="-300"
          max="300"
          step="1"
          value="0"
        />
      </label>
      <label
        >Posição Y
        <input
          type="range"
          id="yControl"
          min="-300"
          max="300"
          step="1"
          value="0"
        />
      </label>
    </div>

    <button id="generate">Gerar e Baixar JPG</button>
    <canvas id="finalCanvas" style="display: none"></canvas>

    <script>
      ;(() => {
        const grid = document.getElementById("grid")
        const canvasOutput = document.getElementById("finalCanvas")
        const ctx = canvasOutput.getContext("2d")
        const generateBtn = document.getElementById("generate")

        const zoomControl = document.getElementById("zoomControl")
        const xControl = document.getElementById("xControl")
        const yControl = document.getElementById("yControl")
        const controlPanel = document.getElementById("controls")
        const dragHandle = document.getElementById("dragHandle")

        const CELL_SIZE = 600
        const BORDER_SIZE = 2
        const COLS = 2
        const ROWS = 3
        const MAX_IMAGES = 6

        const FINAL_WIDTH = COLS * CELL_SIZE + (COLS + 1) * BORDER_SIZE
        const FINAL_HEIGHT = ROWS * CELL_SIZE + (ROWS + 1) * BORDER_SIZE
        canvasOutput.width = FINAL_WIDTH
        canvasOutput.height = FINAL_HEIGHT

        let cells = []
        let selectedCell = null

        function createCell(index) {
          const cell = document.createElement("div")
          cell.className = "grid-cell"

          const input = document.createElement("input")
          input.type = "file"
          input.accept = "image/*"

          const canvas = document.createElement("canvas")
          canvas.width = CELL_SIZE
          canvas.height = CELL_SIZE
          const ctxCell = canvas.getContext("2d")

          let img = null
          let scale = 1
          let offsetX = 0
          let offsetY = 0
          let isDragging = false
          let dragStartX = 0
          let dragStartY = 0

          input.addEventListener("change", e => {
            const file = e.target.files[0]
            if (!file) return
            const reader = new FileReader()
            reader.onload = evt => {
              img = new Image()
              img.onload = () => {
                scale = 1
                offsetX = 0
                offsetY = 0
                draw()
                if (selectedCell === cellData) updateControls()
              }
              img.src = evt.target.result
            }
            reader.readAsDataURL(file)
          })

          function draw() {
            ctxCell.clearRect(0, 0, CELL_SIZE, CELL_SIZE)
            if (!img || !img.complete) return
            const iw = img.width * scale
            const ih = img.height * scale
            ctxCell.drawImage(img, offsetX, offsetY, iw, ih)
          }

          canvas.addEventListener("mousedown", e => {
            if (selectedCell !== cellData) return
            isDragging = true
            dragStartX = e.offsetX
            dragStartY = e.offsetY
          })

          canvas.addEventListener("mousemove", e => {
            if (!isDragging) return
            const dx = e.offsetX - dragStartX
            const dy = e.offsetY - dragStartY
            offsetX += dx
            offsetY += dy
            dragStartX = e.offsetX
            dragStartY = e.offsetY
            draw()
            updateControls()
          })

          canvas.addEventListener("mouseup", () => {
            isDragging = false
          })

          canvas.addEventListener("mouseleave", () => {
            isDragging = false
          })

          function updateControls() {
            zoomControl.value = scale.toFixed(2)
            xControl.value = Math.round(offsetX)
            yControl.value = Math.round(offsetY)
          }

          function setControls() {
            selectedCell = cellData
            controlPanel.classList.remove("hidden")
            updateControls()
          }

          zoomControl.addEventListener("input", () => {
            if (selectedCell !== cellData) return
            scale = parseFloat(zoomControl.value)
            draw()
          })

          xControl.addEventListener("input", () => {
            if (selectedCell !== cellData) return
            offsetX = parseInt(xControl.value)
            draw()
          })

          yControl.addEventListener("input", () => {
            if (selectedCell !== cellData) return
            offsetY = parseInt(yControl.value)
            draw()
          })

          cell.addEventListener("click", () => {
            input.click()
            setControls()
          })

          cell.appendChild(canvas)
          cell.appendChild(input)

          const cellData = {
            canvas,
            ctxCell,
            get img() {
              return img
            },
            set img(value) {
              img = value
            },
            get scale() {
              return scale
            },
            set scale(val) {
              scale = val
            },
            get offsetX() {
              return offsetX
            },
            set offsetX(val) {
              offsetX = val
            },
            get offsetY() {
              return offsetY
            },
            set offsetY(val) {
              offsetY = val
            },
            draw,
            setControls
          }

          return cellData
        }

        for (let i = 0; i < MAX_IMAGES; i++) {
          const cellData = createCell(i)
          cells.push(cellData)
          grid.appendChild(cellData.canvas.parentElement)
        }

        document.body.addEventListener("click", e => {
          if (!controlPanel.contains(e.target) && !grid.contains(e.target)) {
            controlPanel.classList.add("hidden")
            selectedCell = null
          }
        })

        function waitImageLoad(image) {
          return new Promise(resolve => {
            if (!image) resolve()
            else if (image.complete) resolve()
            else image.onload = () => resolve()
          })
        }

        generateBtn.addEventListener("click", async () => {
          ctx.fillStyle = "#fff"
          ctx.fillRect(0, 0, FINAL_WIDTH, FINAL_HEIGHT)

          // Desenhar bordas só nos 61 quadrados usados
          for (let i = 0; i < MAX_IMAGES; i++) {
            const col = i % COLS
            const row = Math.floor(i / COLS)
            const x = BORDER_SIZE + col * (CELL_SIZE + BORDER_SIZE)
            const y = BORDER_SIZE + row * (CELL_SIZE + BORDER_SIZE)
            ctx.strokeStyle = "#007bff"
            ctx.lineWidth = BORDER_SIZE
            ctx.strokeRect(
              x - BORDER_SIZE / 2,
              y - BORDER_SIZE / 2,
              CELL_SIZE + BORDER_SIZE,
              CELL_SIZE + BORDER_SIZE
            )
          }

          // Esperar imagens carregarem
          for (const cell of cells) {
            await waitImageLoad(cell.img)
          }

          // Desenhar as imagens dentro do mosaico, com escala e offset
          cells.forEach((cell, index) => {
            if (!cell.img) return
            if (!cell.img.src) return
            if (!cell.img.complete) return

            const tempCanvas = document.createElement("canvas")
            tempCanvas.width = CELL_SIZE
            tempCanvas.height = CELL_SIZE
            const tempCtx = tempCanvas.getContext("2d")
            tempCtx.clearRect(0, 0, CELL_SIZE, CELL_SIZE)

            const iw = cell.img.width * cell.scale
            const ih = cell.img.height * cell.scale
            tempCtx.drawImage(cell.img, cell.offsetX, cell.offsetY, iw, ih)

            const col = index % COLS
            const row = Math.floor(index / COLS)

            const posX = BORDER_SIZE + col * (CELL_SIZE + BORDER_SIZE)
            const posY = BORDER_SIZE + row * (CELL_SIZE + BORDER_SIZE)
            ctx.drawImage(tempCanvas, posX, posY)
          })

          // Baixar o JPG final
          canvasOutput.toBlob(
            blob => {
              const link = document.createElement("a")
              link.download = "mosaico_61_com_bordas.jpg"
              link.href = URL.createObjectURL(blob)
              link.click()
              URL.revokeObjectURL(link.href)
            },
            "image/jpeg",
            1
          )
        })

        // Drag do painel só pela barra azul (dragHandle)
        let drag = false
        let offsetXdrag = 0
        let offsetYdrag = 0

        dragHandle.addEventListener("mousedown", e => {
          drag = true
          offsetXdrag = e.clientX - controlPanel.offsetLeft
          offsetYdrag = e.clientY - controlPanel.offsetTop
          dragHandle.style.cursor = "grabbing"
        })

        document.addEventListener("mouseup", () => {
          drag = false
          dragHandle.style.cursor = "grab"
        })

        document.addEventListener("mousemove", e => {
          if (!drag) return
          e.preventDefault()
          let left = e.clientX - offsetXdrag
          let top = e.clientY - offsetYdrag
          left = Math.max(
            0,
            Math.min(window.innerWidth - controlPanel.offsetWidth, left)
          )
          top = Math.max(
            0,
            Math.min(window.innerHeight - controlPanel.offsetHeight, top)
          )
          controlPanel.style.left = left + "px"
          controlPanel.style.top = top + "px"
        })
      })()
    </script>
  </body>
</html>
